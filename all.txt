// load ALP program
// load ALP program

import java.util.ArrayList;
import java.util.Scanner;

public class ALPLoader {
    // Define memory size for main memory
    private static final int MEMORY_SIZE = 256;
    // Main memory to store instructions
    private static ArrayList<String> mainMemory = new ArrayList<>(MEMORY_SIZE);

    public static void loadALPToMemory() {
        Scanner scanner = new Scanner(System.in);
        int memoryPointer = 0; // Pointer to keep track of memory addresses

        System.out.println("Enter ALP instructions (type 'END' to stop):");

        while (true) {
            System.out.print("Instruction " + memoryPointer + ": ");
            String instruction = scanner.nextLine().trim();

            // Stop if the user types "END"
            if (instruction.equalsIgnoreCase("END")) {
                break;
            }

            // Check if memory is full
            if (memoryPointer >= MEMORY_SIZE) {
                System.out.println("Error: Main memory is full. Program exceeds available memory.");
                break;
            }

            // Add the instruction to main memory
            mainMemory.add(instruction);
            System.out.println("Loaded '" + instruction + "' into memory address " + memoryPointer);
            memoryPointer++;
        }

        System.out.println("\nProgram successfully loaded into main memory.");
    }

    public static void displayMemory() {
        System.out.println("\nMain Memory Contents:");
        for (int i = 0; i < mainMemory.size(); i++) {
            System.out.println("Memory Address " + i + ": " + mainMemory.get(i));
        }
    }

    public static void main(String[] args) {
        loadALPToMemory(); // Load the ALP program from console input
        displayMemory(); // Display the contents of main memory
    }
}

// MOV A, 5
// ADD B, A
// SUB C, B
// STORE A, 100
// LOAD B, C
// END


// Bankerâ€™s  Deadlock Avoidance algorithm

#include <stdio.h>
#include <stdbool.h>

#define MAX_PROCESSES 10
#define MAX_RESOURCES 10

int processes, resources;
int available[MAX_RESOURCES];
int max[MAX_PROCESSES][MAX_RESOURCES];
int allocation[MAX_PROCESSES][MAX_RESOURCES];
int need[MAX_PROCESSES][MAX_RESOURCES];

void calculateNeed()
{
    for (int i = 0; i < processes; i++)
    {
        for (int j = 0; j < resources; j++)
        {
            need[i][j] = max[i][j] - allocation[i][j];
        }
    }
}

bool isSafeState()
{
    int work[MAX_RESOURCES];
    bool finish[MAX_PROCESSES] = {false};
    int safeSequence[MAX_PROCESSES];
    int count = 0;

    // Initialize work as a copy of available resources
    for (int i = 0; i < resources; i++)
    {
        work[i] = available[i];
    }

    while (count < processes)
    {
        bool found = false;

        for (int i = 0; i < processes; i++)
        {
            if (!finish[i])
            {
                bool canAllocate = true;

                for (int j = 0; j < resources; j++)
                {
                    if (need[i][j] > work[j])
                    {
                        canAllocate = false;
                        break;
                    }
                }

                if (canAllocate)
                {
                    for (int k = 0; k < resources; k++)
                    {
                        work[k] += allocation[i][k];
                    }
                    safeSequence[count++] = i;
                    finish[i] = true;
                    found = true;
                }
            }
        }

        if (!found)
        {
            printf("System is not in a safe state.\n");
            return false;
        }
    }

    printf("System is in a safe state.\nSafe sequence is: ");
    for (int i = 0; i < processes; i++)
    {
        printf("P%d ", safeSequence[i]);
    }
    printf("\n");
    return true;
}

int main()
{
    printf("Enter the number of processes: ");
    scanf("%d", &processes);

    printf("Enter the number of resources: ");
    scanf("%d", &resources);

    printf("Enter the available resources:\n");
    for (int i = 0; i < resources; i++)
    {
        scanf("%d", &available[i]);
    }

    printf("Enter the maximum resource matrix:\n");
    for (int i = 0; i < processes; i++)
    {
        for (int j = 0; j < resources; j++)
        {
            scanf("%d", &max[i][j]);
        }
    }

    printf("Enter the allocation matrix:\n");
    for (int i = 0; i < processes; i++)
    {
        for (int j = 0; j < resources; j++)
        {
            scanf("%d", &allocation[i][j]);
        }
    }

    calculateNeed();
    isSafeState();

    return 0;
}


#bash programs

#!/bin/bash

# Factorial using recursion with a function
factorial() {
    if [ $1 -le 1 ]; then
        echo 1
    else
        local n=$(( $1 - 1 ))
        local result=$(factorial $n)
        echo $(( $1 * result ))
    fi
}

# Factorial without recursion
factorial_no_recursion() {
    n=$1
    result=1
    while [ $n -gt 1 ]; do
        result=$(( result * n ))
        n=$(( n - 1 ))
    done
    echo "$result"
}

# Bubble sort implementation
bubble_sort() {
    arr=("$@")
    len=${#arr[@]}
    for ((i=0; i<$len; i++)); do
        for ((j=0; j<$len-i-1; j++)); do
            if [ ${arr[$j]} -gt ${arr[$((j+1))]} ]; then
                # Swap elements
                temp=${arr[$j]}
                arr[$j]=${arr[$((j+1))]}
                arr[$((j+1))]=$temp
            fi
        done
    done
    echo "${arr[@]}"
}

# Count occurrences of a substring in a string
count_substring() {
    string=$1
    substring=$2
    count=0
    while [[ $string =~ $substring ]]; do
        ((count++))
        string=${string#*$substring}
    done
    echo "$count"
}

# Sum of digits of a number
sum_of_digits() {
    n=$1
    sum=0
    while [ $n -gt 0 ]; do
        digit=$(( n % 10 ))
        sum=$(( sum + digit ))
        n=$(( n / 10 ))
    done
    echo "$sum"
}

# Reverse digits of a number
reverse_digits() {
    n=$1
    reversed_num=0
    while [ $n -gt 0 ]; do
        digit=$(( n % 10 ))
        reversed_num=$(( reversed_num * 10 + digit ))
        n=$(( n / 10 ))
    done
    echo "$reversed_num"
}

# Armstrong number check
is_armstrong() {
    n=$1
    num_digits=${#n}
    sum_of_powers=0
    temp=$n
    while [ $temp -gt 0 ]; do
        digit=$(( temp % 10 ))
        sum_of_powers=$(( sum_of_powers + digit ** num_digits ))
        temp=$(( temp / 10 ))
    done
    if [ $sum_of_powers -eq $n ]; then
        echo "$n is an Armstrong number."
    else
        echo "$n is not an Armstrong number."
    fi
}

# Display menu
while true; do
    clear
    echo "==============================="
    echo "       Menu Driven Program"
    echo "==============================="
    echo "1. Calculate Factorial (Recursion)"
    echo "2. Calculate Factorial (Without Recursion)"
    echo "3. Bubble Sort"
    echo "4. Count Occurrences of Substring"
    echo "5. Sum of Digits"
    echo "6. Reverse Digits"
    echo "7. Armstrong Number Check"
    echo "8. Exit"
    echo "==============================="
    read -p "Enter your choice (1-8): " choice
    
    case $choice in
        1)
            read -p "Enter a number to find its factorial: " n
            echo "Factorial of $n is $(factorial $n)"
            ;;
        2)
            read -p "Enter a number to find its factorial: " n
            echo "Factorial of $n without recursion is $(factorial_no_recursion $n)"
            ;;
        3)
            read -p "Enter space-separated numbers for sorting: " -a arr
            echo "Sorted array: $(bubble_sort ${arr[@]})"
            ;;
        4)
            read -p "Enter the string: " string
            read -p "Enter the substring to count: " substring
            echo "The substring '$substring' occurs $(count_substring "$string" "$substring") times."
            ;;
        5)
            read -p "Enter a number to calculate the sum of digits: " n
            echo "The sum of digits of $n is $(sum_of_digits $n)"
            ;;
        6)
            read -p "Enter a number to reverse its digits: " n
            echo "The reversed digits of $n is $(reverse_digits $n)"
            ;;
        7)
            read -p "Enter a number to check if it's an Armstrong number: " n
            echo "$(is_armstrong $n)"
            ;;
        8)
            echo "Exiting the program. Goodbye!"
            exit 0
            ;;
        *)
            echo "Invalid choice. Please try again."
            ;;
    esac
done

// C-SCAN disk scheduling

#include <stdio.h>
#include <stdlib.h>

void CSCAN(int head, int requests[], int n, int disk_size)
{
    int total_seek_time = 0;
    int temp, i, j;

    // Sort the request array
    for (i = 0; i < n - 1; i++)
    {
        for (j = 0; j < n - i - 1; j++)
        {
            if (requests[j] > requests[j + 1])
            {
                temp = requests[j];
                requests[j] = requests[j + 1];
                requests[j + 1] = temp;
            }
        }
    }

    // Find the position of the head in the sorted request array
    int pos = 0;
    for (i = 0; i < n; i++)
    {
        if (head < requests[i])
        {
            pos = i;
            break;
        }
    }

    printf("\nC-SCAN Disk Scheduling\n");
    printf("Initial Head Position: %d\n", head);

    printf("\nRequest\tCurrent Head Position\tSeek Time\n");
    printf("-------\t----------------------\t---------\n");

    // Move towards the end of the disk serving requests on the right
    for (i = pos; i < n; i++)
    {
        int seek_time = abs(requests[i] - head);
        total_seek_time += seek_time;
        printf("%d\t\t%d\t\t\t%d\n", requests[i], head, seek_time);
        head = requests[i];
    }

    // Jump to the beginning of the disk
    if (head != disk_size - 1)
    {
        int seek_time = abs((disk_size - 1) - head);
        total_seek_time += seek_time;
        printf("%d\t\t%d\t\t\t%d\n", disk_size - 1, head, seek_time);
        head = 0; // Jump to 0 (beginning of the disk)
        printf("%d\t\t%d\t\t\t%d\n", 0, disk_size - 1, head);
    }

    // Continue serving requests from the start to the head position
    for (i = 0; i < pos; i++)
    {
        int seek_time = abs(requests[i] - head);
        total_seek_time += seek_time;
        printf("%d\t\t%d\t\t\t%d\n", requests[i], head, seek_time);
        head = requests[i];
    }

    printf("\nTotal Seek Time: %d\n", total_seek_time);
}

int main()
{
    int n, head, disk_size;

    // Input number of requests
    printf("Enter the number of disk requests: ");
    scanf("%d", &n);

    int requests[n];

    // Input the disk requests
    printf("Enter the disk requests:\n");
    for (int i = 0; i < n; i++)
    {
        printf("Request %d: ", i + 1);
        scanf("%d", &requests[i]);
    }

    // Input initial head position
    printf("Enter the initial head position: ");
    scanf("%d", &head);

    // Input the size of the disk
    printf("Enter the disk size: ");
    scanf("%d", &disk_size);

    // Call the CSCAN function to calculate seek time
    CSCAN(head, requests, n, disk_size);

    return 0;
}



//read and copy the contents of file

import java.io.*;
import java.util.Scanner;

public class FileDisplay {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Prompt for the source file name
        System.out.print("Enter the source file name: ");
        String sourceFile = scanner.nextLine();
        // Display contents character by character
        displayCharacterByCharacter(sourceFile);
        // Display contents line by line
        displayLineByLine(sourceFile);
    }

    // Method to display file content character by character
    public static void displayCharacterByCharacter(String source) {
        try (FileReader fileReader = new FileReader(source)) {
            int character;
            System.out.println("Displaying contents character by character:");
            while ((character = fileReader.read()) != -1) {
                System.out.print((char) character); // Print each character
            }
            System.out.println(); // Newline after character-by-character display
        } catch (IOException e) {
            System.out.println("An error occurred during character-by-character display: " + e.getMessage());
        }
    }

    // Method to display file content line by line
    public static void displayLineByLine(String source) {
        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(source))) {
            String line;
            System.out.println("Displaying contents line by line:");
            while ((line = bufferedReader.readLine()) != null) {
                System.out.println(line); // Print each line
            }
        } catch (IOException e) {
            System.out.println("An error occurred during line-by-line display: " + e.getMessage());
        }
    }
}

// Deadlock detection algorithm

#include <stdio.h>
#include <stdbool.h>
#define MAX_PROCESSES 10
#define MAX_RESOURCES 10

int processes, resources;
int available[MAX_RESOURCES];
int allocation[MAX_PROCESSES][MAX_RESOURCES];
int request[MAX_PROCESSES][MAX_RESOURCES];

void deadlockDetection()
{
    bool finish[MAX_PROCESSES] = {false};
    int work[MAX_RESOURCES];

    // Initialize work as a copy of available resources
    for (int i = 0; i < resources; i++)
    {
        work[i] = available[i];
    }

    bool deadlock = false;
    int deadlockedProcesses[MAX_PROCESSES];
    int deadlockedCount = 0;

    for (int count = 0; count < processes; count++)
    {
        bool found = false;

        for (int i = 0; i < processes; i++)
        {
            if (!finish[i])
            {
                bool canProceed = true;

                // Check if the process's request can be satisfied
                for (int j = 0; j < resources; j++)
                {
                    if (request[i][j] > work[j])
                    {
                        canProceed = false;
                        break;
                    }
                }

                // If the request can be satisfied, allocate resources temporarily
                if (canProceed)
                {
                    for (int j = 0; j < resources; j++)
                    {
                        work[j] += allocation[i][j];
                    }
                    finish[i] = true;
                    found = true;
                }
            }
        }

        // If no process could proceed in this round, break out
        if (!found)
        {
            break;
        }
    }

    // Check for processes still marked as unfinished
    for (int i = 0; i < processes; i++)
    {
        if (!finish[i])
        {
            deadlockedProcesses[deadlockedCount++] = i;
            deadlock = true;
        }
    }

    if (deadlock)
    {
        printf("System is in a deadlock state.\n");
        printf("Deadlocked processes: ");
        for (int i = 0; i < deadlockedCount; i++)
        {
            printf("P%d ", deadlockedProcesses[i]);
        }
        printf("\n");
    }
    else
    {
        printf("System is not in a deadlock state.\n");
    }
}

int main()
{
    printf("Enter the number of processes: ");
    scanf("%d", &processes);

    printf("Enter the number of resources: ");
    scanf("%d", &resources);

    printf("Enter the available resources:\n");
    for (int i = 0; i < resources; i++)
    {
        scanf("%d", &available[i]);
    }

    printf("Enter the allocation matrix:\n");
    for (int i = 0; i < processes; i++)
    {
        for (int j = 0; j < resources; j++)
        {
            scanf("%d", &allocation[i][j]);
        }
    }

    printf("Enter the request matrix:\n");
    for (int i = 0; i < processes; i++)
    {
        for (int j = 0; j < resources; j++)
        {
            scanf("%d", &request[i][j]);
        }
    }

    deadlockDetection();

    return 0;
}


//dining philosopher semaphore

#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <unistd.h>

#define N 5

sem_t forks[N];

void *philosopher(void *arg)
{
    int id = *((int *)arg);

    for (int i = 0; i < 3; i++)
    {
        printf("Philosopher %d is thinking.\n", id);
        usleep(100000);

        sem_wait(&forks[id]);
        sem_wait(&forks[(id + 1) % N]);

        printf("Philosopher %d is eating.\n", id);
        usleep(100000);

        sem_post(&forks[id]);
        sem_post(&forks[(id + 1) % N]);

        printf("Philosopher %d finished eating.\n", id);
        usleep(100000);
    }
    return NULL;
}

int main()
{
    pthread_t philosophers[N];
    int ids[N];

    for (int i = 0; i < N; i++)
        sem_init(&forks[i], 0, 1);

    for (int i = 0; i < N; i++)
    {
        ids[i] = i;
        pthread_create(&philosophers[i], NULL, philosopher, &ids[i]);
    }

    for (int i = 0; i < N; i++)
        pthread_join(philosophers[i], NULL);

    for (int i = 0; i < N; i++)
        sem_destroy(&forks[i]);

    return 0;
}


// FCFS disk scheduling

#include <stdio.h>
#include <stdlib.h>

void FCFS(int head, int requests[], int n)
{
    int total_seek_time = 0;
    int current_position = head;

    printf("\nFCFS Disk Scheduling\n");
    printf("Initial Head Position: %d\n", head);

    printf("\nRequest\tCurrent Head Position\tSeek Time\n");
    printf("-------\t----------------------\t---------\n");

    for (int i = 0; i < n; i++)
    {
        int seek_time = abs(requests[i] - current_position);
        total_seek_time += seek_time;

        printf("%d\t\t%d\t\t\t%d\n", requests[i], current_position, seek_time);

        current_position = requests[i];
    }

    printf("\nTotal Seek Time: %d\n", total_seek_time);
}

int main()
{
    int n, head;

    // Input number of requests
    printf("Enter the number of disk requests: ");
    scanf("%d", &n);

    int requests[n];

    // Input the disk requests
    printf("Enter the disk requests:\n");
    for (int i = 0; i < n; i++)
    {
        printf("Request %d: ", i + 1);
        scanf("%d", &requests[i]);
    }

    // Input initial head position
    printf("Enter the initial head position: ");
    scanf("%d", &head);

    // Call the FCFS function to calculate seek time
    FCFS(head, requests, n);

    return 0;
}


// FIFO page replacement algorithms

#include <stdio.h>

#define MAX_FRAMES 10

int isPageInFrames(int frames[], int frameCount, int page)
{
    for (int i = 0; i < frameCount; i++)
    {
        if (frames[i] == page)
        {
            return 1; // Page found in frames
        }
    }
    return 0; // Page not found
}

int main()
{
    int frameCount, pageCount;
    int pageFaults = 0;
    int nextFrameToReplace = 0; // To keep track of which frame to replace next

    // Input: Number of frames and number of pages in the reference string
    printf("Enter the number of frames: ");
    scanf("%d", &frameCount);

    printf("Enter the number of pages in the reference string: ");
    scanf("%d", &pageCount);

    int pages[pageCount];
    printf("Enter the reference string (space-separated): ");
    for (int i = 0; i < pageCount; i++)
    {
        scanf("%d", &pages[i]);
    }

    int frames[MAX_FRAMES];
    for (int i = 0; i < frameCount; i++)
    {
        frames[i] = -1; // Initialize frames as empty
    }

    // Processing each page in the reference string
    for (int i = 0; i < pageCount; i++)
    {
        int currentPage = pages[i];

        // Check if the current page is already in the frames
        if (!isPageInFrames(frames, frameCount, currentPage))
        {
            // Page fault occurs as the page is not in frames
            frames[nextFrameToReplace] = currentPage;                   // Replace the page at nextFrameToReplace
            pageFaults++;                                               // Increment page faults
            nextFrameToReplace = (nextFrameToReplace + 1) % frameCount; // Move to the next frame
        }
    }

    printf("\nTotal Page Faults: %d\n", pageFaults);

    return 0;
}


#loops in bash

#!/bin/bash

# Function for if-else statement
if_else_demo() {
    read -p "Enter your age: " age
    if (( age < 18 )); then
        echo "You are a minor."
    elif (( age <= 65 )); then
        echo "You are an adult."
    else
        echo "You are a senior."
    fi
}


# Function for for loop to print numbers from start to end
for_loop_demo() {
    read -p "Enter the start number: " start
    read -p "Enter the end number: " end
    for (( i=start; i<=end; i++ )); do
        echo "Number $i"
    done
}


# Function to check if a number is prime
is_prime() {
    local num=$1
    if (( num <= 1 )); then
        return 1
    fi
    for (( i=2; i*i<=num; i++ )); do
        if (( num % i == 0 )); then
            return 1
        fi
    done
    return 0
}


# Function for while loop demonstration (prime numbers)
while_loop_demo() {
    read -p "Enter a start number: " start
    read -p "Enter an end number: " end
    while (( start <= end )); do
        if is_prime $start; then
            echo "Prime number: $start"
        fi
        ((start++))
    done
}


# Function to calculate factorial of a number
factorial() {
    local num=$1
    local factorial=1
    local i=1
    until (( i > num )); do
        factorial=$(( factorial * i ))
        ((i++))
    done
    echo $factorial
}


# Function for until loop demonstration (factorial)
until_loop_demo() {
    read -p "Enter a number to calculate factorial: " num
    result=$(factorial $num)
    echo "Factorial of $num is $result"
}


# Display the menu
while true; do
    echo "Menu:"
    echo "1) If-Else Statement"
    echo "2) For Loop"
    echo "3) While Loop"
    echo "4) Until Loop"
    echo "5) Exit"
    read -p "Choose an option: " choice


    case $choice in
        1)
            if_else_demo
            ;;
        2)
            for_loop_demo
            ;;
        3)
            while_loop_demo
            ;;
        4)
            until_loop_demo
            ;;
        5)
            echo "Exiting..."
            break
            ;;
        *)
            echo "Invalid option, please try again."
            ;;
    esac
done


// LRU page replacement algorithms

#include <stdio.h>

#define MAX_FRAMES 10

int findLRU(int frames[], int time[], int frameCount)
{
    int min = time[0], minIndex = 0;
    for (int i = 1; i < frameCount; i++)
    {
        if (time[i] < min)
        {
            min = time[i];
            minIndex = i;
        }
    }
    return minIndex; // Return the index of the LRU page
}

int isPageInFrames(int frames[], int frameCount, int page)
{
    for (int i = 0; i < frameCount; i++)
    {
        if (frames[i] == page)
        {
            return 1; // Page found in frames
        }
    }
    return 0; // Page not found
}

int main()
{
    int frameCount, pageCount;
    int pageFaults = 0;

    // Input: Number of frames and number of pages in the reference string
    printf("Enter the number of frames: ");
    scanf("%d", &frameCount);

    printf("Enter the number of pages in the reference string: ");
    scanf("%d", &pageCount);

    int pages[pageCount];
    printf("Enter the reference string (space-separated): ");
    for (int i = 0; i < pageCount; i++)
    {
        scanf("%d", &pages[i]);
    }

    int frames[MAX_FRAMES];
    int time[MAX_FRAMES]; // Array to keep track of the last used time of each frame
    for (int i = 0; i < frameCount; i++)
    {
        frames[i] = -1; // Initialize frames as empty
        time[i] = 0;    // Initialize the last used time
    }

    // Processing each page in the reference string
    for (int i = 0; i < pageCount; i++)
    {
        int currentPage = pages[i];

        // Check if the current page is already in the frames
        if (!isPageInFrames(frames, frameCount, currentPage))
        {
            // Page fault occurs as the page is not in frames
            int lruIndex = findLRU(frames, time, frameCount); // Find the index of the LRU page
            frames[lruIndex] = currentPage;                   // Replace the LRU page with the current page
            pageFaults++;                                     // Increment page faults
        }

        // Update the time of the current page
        for (int j = 0; j < frameCount; j++)
        {
            if (frames[j] == currentPage)
            {
                time[j] = i; // Update the last used time for the current page
                break;
            }
        }
    }

    printf("\nTotal Page Faults: %d\n", pageFaults);

    return 0;
}


//matrix operation

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>


// Define the dimensions of the matrices
#define M 3  
#define N 3
#define P 3  


// Matrices
int A[M][N];
int B[N][P];
int C[M][P];


// Structure to pass data to threads
typedef struct {
    int row;
    int col;
} thread_data_t;


// Thread function to perform matrix multiplication for a specific element
void* multiply(void* arg) {
    thread_data_t* data = (thread_data_t*) arg;
    int row = data->row;
    int col = data->col;
    C[row][col] = 0;  


    // Perform the matrix multiplication for a single element
    for (int k = 0; k < N; k++) {
        C[row][col] += A[row][k] * B[k][col];
    }


    pthread_exit(NULL);
}


int main() {
    pthread_t threads[M * P];        
    thread_data_t thread_data[M * P];
    // Initialize matrices A and B
    printf("Matrix A:\n");
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
            A[i][j] = rand() % 10;
            printf("%d ", A[i][j]);
        }
        printf("\n");
    }


    printf("\nMatrix B:\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < P; j++) {
            B[i][j] = rand() % 10;  // Random numbers between 0 and 9
            printf("%d ", B[i][j]);
        }
        printf("\n");
    }




    int thread_idx = 0;
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < P; j++) {
            thread_data[thread_idx].row = i;
            thread_data[thread_idx].col = j;
            pthread_create(&threads[thread_idx], NULL, multiply, (void*)&thread_data[thread_idx]);
            thread_idx++;
        }
    }


    // Join all threads
    for (int i = 0; i < M * P; i++) {
        pthread_join(threads[i], NULL);
    }


    // Display the result matrix C
    printf("\nResultant Matrix C (A * B):\n");
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < P; j++) {
            printf("%d ", C[i][j]);
        }
        printf("\n");
    }


    return 0;
}


// Opcode error in a given job
import java.util.*;

public class OpcodeChecker {
    // List of valid opcodes
    private static final Set<String> validOpcodes = new HashSet<>(Arrays.asList(
            "GD", "PD", "LR", "SR", "H", "BT", "CR"));

    public static void main(String[] args) {
        // Sample job input
        String job = "$AMJ020200160005\n" +
                "GD20PD20LD20SR30SR31PD30SR40SR41SR42PD40\n" +
                "SR50SR51PD50SR60PD60H\n" +
                "$DTA\n" +
                "*\n" +
                "$END0202";

        // Process the job
        checkOpcodeErrors(job);
    }

    // Method to check for opcode errors
    public static void checkOpcodeErrors(String job) {
        // Split job into lines
        String[] lines = job.split("\n");

        // Boolean to track if we are in the instructions section
        boolean inInstructions = false;

        // Loop through each line
        for (String line : lines) {
            // Skip lines until we reach the instructions part
            if (line.startsWith("$AMJ")) {
                inInstructions = true;
                continue;
            }
            if (line.startsWith("$DTA") || line.startsWith("$END")) {
                inInstructions = false;
            }

            // Process instructions only if in the instructions section
            if (inInstructions) {
                // Extract opcodes and validate them
                checkInstructions(line);
            }
        }
    }

    // Method to check each instruction in the line
    public static void checkInstructions(String line) {
        // Split line into opcode sequences (2 chars for opcode, rest for operand)
        for (int i = 0; i < line.length(); i += 4) {
            if (i + 2 <= line.length()) {
                String opcode = line.substring(i, i + 2); // Extract the opcode part
                // Validate opcode
                if (!validOpcodes.contains(opcode)) {
                    raiseInterrupt(opcode);
                }
            }
        }
    }

    // Method to raise an interrupt if an invalid opcode is found
    public static void raiseInterrupt(String invalidOpcode) {
        System.err.println("Interrupt Raised: Invalid Opcode Detected - " + invalidOpcode);
    }
}


//  Oprand error in a given job
import java.util.*;

public class OperandChecker {
    // List of valid opcodes
    private static final Set<String> validOpcodes = new HashSet<>(Arrays.asList(
            "GD", "PD", "LR", "SR", "H"));

    // Define the valid range for operands (00-99 for 2-digit numbers)
    private static final int MIN_OPERAND = 0;
    private static final int MAX_OPERAND = 99;

    public static void main(String[] args) {
        // Sample job input
        String job = "$AMJ020200160005\n" +
                "GD20PD2ALR20SR30SR31PD30SR40SR41SR42PD40\n" +
                "SR50SR51PD50SR60PD60H\n" +
                "$DTA\n" +
                "*\n" +
                "$END0202";

        // Process the job
        checkOperandErrors(job);
    }

    // Method to check for operand errors
    public static void checkOperandErrors(String job) {
        // Split job into lines
        String[] lines = job.split("\n");

        // Boolean to track if we are in the instructions section
        boolean inInstructions = false;

        // Loop through each line
        for (String line : lines) {
            // Identify the start and end of the instructions section
            if (line.startsWith("$AMJ")) {
                inInstructions = true;
                continue;
            }
            if (line.startsWith("$DTA") || line.startsWith("$END")) {
                inInstructions = false;
            }

            // Process instructions only if in the instructions section
            if (inInstructions) {
                // Validate each instruction in the line
                checkInstructions(line);
            }
        }
    }

    // Method to check each instruction in the line
    public static void checkInstructions(String line) {
        // Process each opcode-operand pair (every 4 characters)
        for (int i = 0; i < line.length(); i += 4) {
            if (i + 4 <= line.length()) {
                String opcode = line.substring(i, i + 2); // Extract the opcode part
                String operandStr = line.substring(i + 2, i + 4); // Extract the operand part

                // Validate opcode
                if (!validOpcodes.contains(opcode)) {
                    raiseOpcodeInterrupt(opcode);
                } else {
                    // Validate operand
                    if (!isValidOperand(operandStr)) {
                        raiseOperandInterrupt(operandStr);
                    }
                }
            }
        }
    }

    // Method to check if the operand is valid (numeric and within range)
    public static boolean isValidOperand(String operand) {
        try {
            int value = Integer.parseInt(operand);
            return value >= MIN_OPERAND && value <= MAX_OPERAND;
        } catch (NumberFormatException e) {
            return false; // Operand is not a valid number
        }
    }

    // Method to raise an interrupt for invalid opcodes
    public static void raiseOpcodeInterrupt(String invalidOpcode) {
        System.err.println("Interrupt Raised: Invalid Opcode Detected - " + invalidOpcode);
    }

    // Method to raise an interrupt for invalid operands
    public static void raiseOperandInterrupt(String invalidOperand) {
        System.err.println("Interrupt Raised: Invalid Operand Detected - " + invalidOperand);
    }
}


//Optimal page replacement algorithms

#include <stdio.h>


#define MAX_FRAMES 10


int findOptimal(int frames[], int frameCount, int pages[], int pageCount, int currentIndex) {
    int farthest = currentIndex, indexToReplace = -1;


    for (int i = 0; i < frameCount; i++) {
        int j;
        for (j = currentIndex; j < pageCount; j++) {
            if (frames[i] == pages[j]) {
                if (j > farthest) {
                    farthest = j;
                    indexToReplace = i;
                }
                break;
            }
        }
        // If the frame is never going to be used again
        if (j == pageCount) {
            return i; // Replace this frame
        }
    }
   
    // If all pages are used in the future, replace the one that is used the farthest in the future
    return (indexToReplace != -1) ? indexToReplace : 0;
}


int isPageInFrames(int frames[], int frameCount, int page) {
    for (int i = 0; i < frameCount; i++) {
        if (frames[i] == page) {
            return 1; // Page found in frames
        }
    }
    return 0; // Page not found
}


int main() {
    int frameCount, pageCount;
    int pageFaults = 0;


    // Input: Number of frames and number of pages in the reference string
    printf("Enter the number of frames: ");
    scanf("%d", &frameCount);


    printf("Enter the number of pages in the reference string: ");
    scanf("%d", &pageCount);


    int pages[pageCount];
    printf("Enter the reference string (space-separated): ");
    for (int i = 0; i < pageCount; i++) {
        scanf("%d", &pages[i]);
    }


    int frames[MAX_FRAMES];
    for (int i = 0; i < frameCount; i++) {
        frames[i] = -1; // Initialize frames as empty
    }


    // Processing each page in the reference string
    for (int i = 0; i < pageCount; i++) {
        int currentPage = pages[i];


        // Check if the current page is already in the frames
        if (!isPageInFrames(frames, frameCount, currentPage)) {
            // Page fault occurs as the page is not in frames
            int indexToReplace = findOptimal(frames, frameCount, pages, pageCount, i); // Find the optimal frame to replace
            frames[indexToReplace] = currentPage; // Replace the optimal frame with the current page
            pageFaults++; // Increment page faults
        }
    }


    printf("\nTotal Page Faults: %d\n", pageFaults);


    return 0;
}


//producer consumer mutex

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>


#define BUFFER_SIZE 5


int buffer[BUFFER_SIZE];
int count = 0;
pthread_mutex_t mutex;
pthread_cond_t not_full, not_empty;


void* producer(void* arg) {
    int item;
    for (int i = 0; i < 10; i++) {
        item = rand() % 100;
        pthread_mutex_lock(&mutex);
        while (count == BUFFER_SIZE)
            pthread_cond_wait(&not_full, &mutex);
        buffer[count++] = item;
        printf("Producer produced: %d\n", item);
        pthread_cond_signal(&not_empty);
        pthread_mutex_unlock(&mutex);
        // Removed sleep(1); // No sleep for faster execution
    }
    return NULL;
}


void* consumer(void* arg) {
    int item;
    for (int i = 0; i < 10; i++) {
        pthread_mutex_lock(&mutex);
        while (count == 0)
            pthread_cond_wait(&not_empty, &mutex);
        item = buffer[--count];
        printf("Consumer consumed: %d\n", item);
        pthread_cond_signal(&not_full);
        pthread_mutex_unlock(&mutex);
        // Removed sleep(1); // No sleep for faster execution
    }
    return NULL;
}


int main() {
    pthread_t prod_thread, cons_thread;


    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&not_full, NULL);
    pthread_cond_init(&not_empty, NULL);


    pthread_create(&prod_thread, NULL, producer, NULL);
    pthread_create(&cons_thread, NULL, consumer, NULL);


    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);


    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&not_full);
    pthread_cond_destroy(&not_empty);


    return 0;
}


//producer consumer semaphore

import java.util.LinkedList;
import java.util.concurrent.Semaphore;


class ProducerConsumer {
  private final LinkedList<Integer> buffer = new LinkedList<>();
  private final int capacity = 5; // Size of the buffer
  private final Semaphore mutex; // Mutual exclusion for buffer access
  private final Semaphore empty; // Semaphore to count empty slots in buffer
  private final Semaphore full; // Semaphore to count full slots in buffer


  public ProducerConsumer() {
    mutex = new Semaphore(1); // Binary semaphore for mutual exclusion
    empty = new Semaphore(capacity); // Counting semaphore for empty slots
    full = new Semaphore(0); // Counting semaphore for full slots
  }


  // Producer class
  class Producer implements Runnable {
    @Override
    public void run() {
      int item = 0; // Item to be produced
      while (true) {
        try {
          empty.acquire(); // Wait if buffer is full
          mutex.acquire(); // Protect buffer access


          // Critical Section for Producer (Inserting item)
          buffer.add(item);
          System.out.println("Produced: " + item);
          item++; // Increment item to produce new one


          mutex.release(); // Release buffer access
          full.release(); // Signal that there's a full slot now


          // Simulate production time
          Thread.sleep(1000);
        } catch (InterruptedException e) {
          System.out.println(e.getMessage());
        }
      }
    }
  }


  // Consumer class
  class Consumer implements Runnable {
    @Override
    public void run() {
      while (true) {
        try {
          full.acquire(); // Wait if buffer is empty
          mutex.acquire(); // Protect buffer access


          // Critical Section for Consumer (Removing item)
          int item = buffer.removeFirst();
          System.out.println("Consumed: " + item);


          mutex.release(); // Release buffer access
          empty.release(); // Signal that there's an empty slot now


          // Simulate consumption time
          Thread.sleep(1500);
        } catch (InterruptedException e) {
          System.out.println(e.getMessage());
        }
      }
    }
  }


  public static void main(String[] args) {
    ProducerConsumer pc = new ProducerConsumer();


    // Creating producer and consumer threads
    Thread producer1 = new Thread(pc.new Producer());
    Thread producer2 = new Thread(pc.new Producer());
    Thread producer3 = new Thread(pc.new Producer());
    Thread consumer1 = new Thread(pc.new Consumer());
    Thread consumer2 = new Thread(pc.new Consumer());


    // Start threads
    producer1.start();
    producer2.start();
    producer3.start();
    consumer1.start();
    consumer2.start();
  }
}


//reader writer mutex

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>


// Shared data and synchronization variables
int shared_data = 0;
int reader_count = 0;
pthread_mutex_t resource_mutex;      // Mutex for exclusive access to shared data
pthread_mutex_t reader_count_mutex;   // Mutex for protecting reader count
int max_operations = 5; // Number of iterations for readers and writers


// Reader function
void* reader(void* arg) {
    int reader_id = *((int*)arg);
    free(arg);
    int read_count = 0;


    while (read_count < max_operations) { 
        // Entry section for reader
        pthread_mutex_lock(&reader_count_mutex);
        reader_count++;
        if (reader_count == 1) {
            pthread_mutex_lock(&resource_mutex); // First reader locks the resource
        }
        pthread_mutex_unlock(&reader_count_mutex);


        // Reading section
        printf("Reader %d is reading the shared data: %d\n", reader_id, shared_data);


        // Exit section for reader
        pthread_mutex_lock(&reader_count_mutex);
        reader_count--;
        if (reader_count == 0) {
            pthread_mutex_unlock(&resource_mutex); // Last reader unlocks the resource
        }
        pthread_mutex_unlock(&reader_count_mutex);


        read_count++; // Increment read count
    }


    return NULL;
}


// Writer function
void* writer(void* arg) {
    int writer_id = *((int*)arg);
    free(arg);
    int write_count = 0;


    while (write_count < max_operations) { 
        pthread_mutex_lock(&resource_mutex);  // Writer locks the resource
        shared_data++;
        printf("Writer %d updated shared data to: %d\n", writer_id, shared_data);
        pthread_mutex_unlock(&resource_mutex);  // Writer releases the resource
        
        write_count++; // Increment write count
    }


    return NULL;
}


int main() {
    pthread_t readers[5], writers[2];
    pthread_mutex_init(&resource_mutex, NULL);
    pthread_mutex_init(&reader_count_mutex, NULL);


    // Create reader threads
    for (int i = 0; i < 5; i++) {
        int* id = malloc(sizeof(int));
        *id = i + 1;
        pthread_create(&readers[i], NULL, reader, id);
    }


    // Create writer threads
    for (int i = 0; i < 2; i++) {
        int* id = malloc(sizeof(int));
        *id = i + 1;
        pthread_create(&writers[i], NULL, writer, id);
    }


    // Wait for threads to complete
    for (int i = 0; i < 5; i++) {
        pthread_join(readers[i], NULL);
    }
    for (int i = 0; i < 2; i++) {
        pthread_join(writers[i], NULL);
    }


    // Destroy mutexes
    pthread_mutex_destroy(&resource_mutex);
    pthread_mutex_destroy(&reader_count_mutex);


    return 0;
}


//reader writer semaphore

import java.util.concurrent.Semaphore;


class ReaderWriter {
  private int readCount = 0; // Count of active readers
  private final Semaphore mutex; // Mutex to protect readCount
  private final Semaphore writeLock; // WriteLock to ensure only one writer


  public ReaderWriter() {
    mutex = new Semaphore(1); // Binary semaphore for reader count update
    writeLock = new Semaphore(1); // Binary semaphore for writer synchronization
  }


  // Reader class
  class Reader implements Runnable {
    private final String readerName;


    Reader(String name) {
      this.readerName = name;
    }


    @Override
    public void run() {
      try {
        // Entry Section for Reader
        mutex.acquire(); // Protecting readCount
        readCount++;
        if (readCount == 1) {
          writeLock.acquire(); // First reader locks the writeLock
        }
        mutex.release(); // Release mutex after updating readCount


        // Critical Section for Reader (Reading)
        System.out.println(readerName + " is READING");


        // Simulate reading with sleep
        Thread.sleep(1000);


        // Exit Section for Reader
        mutex.acquire();
        readCount--;
        if (readCount == 0) {
          writeLock.release(); // Last reader releases the writeLock
        }
        mutex.release();


        System.out.println(readerName + " has FINISHED READING");


      } catch (InterruptedException e) {
        System.out.println(e.getMessage());
      }
    }
  }


  // Writer class
  class Writer implements Runnable {
    private final String writerName;


    Writer(String name) {
      this.writerName = name;
    }


    @Override
    public void run() {
      try {
        // Entry Section for Writer
        writeLock.acquire(); // Writer acquires writeLock


        // Critical Section for Writer (Writing)
        System.out.println(writerName + " is WRITING");


        // Simulate writing with sleep
        Thread.sleep(1500);


        // Exit Section for Writer
        writeLock.release();


        System.out.println(writerName + " has FINISHED WRITING");


      } catch (InterruptedException e) {
        System.out.println(e.getMessage());
      }
    }
  }


  public static void main(String[] args) {
    ReaderWriter rw = new ReaderWriter();


    // Creating reader and writer threads
    Thread reader1 = new Thread(rw.new Reader("Reader 1"));
    Thread reader2 = new Thread(rw.new Reader("Reader 2"));
    Thread writer1 = new Thread(rw.new Writer("Writer 1"));
    Thread writer2 = new Thread(rw.new Writer("Writer 2"));


    // Start threads
    reader1.start();
    writer1.start();
    reader2.start();
    writer2.start();
  }
}


// SCAN disk scheduling

#include <stdio.h>
#include <stdlib.h>

void SCAN(int head, int requests[], int n, int disk_size, int direction)
{
    int total_seek_time = 0;
    int temp, i, j;

    // Sort the request array
    for (i = 0; i < n - 1; i++)
    {
        for (j = 0; j < n - i - 1; j++)
        {
            if (requests[j] > requests[j + 1])
            {
                temp = requests[j];
                requests[j] = requests[j + 1];
                requests[j + 1] = temp;
            }
        }
    }

    // Find the position of the head in the sorted request array
    int pos = 0;
    for (i = 0; i < n; i++)
    {
        if (head < requests[i])
        {
            pos = i;
            break;
        }
    }

    printf("\nSCAN Disk Scheduling\n");
    printf("Initial Head Position: %d\n", head);
    printf("Direction: %s\n", direction == 1 ? "Right" : "Left");

    printf("\nRequest\tCurrent Head Position\tSeek Time\n");
    printf("-------\t----------------------\t---------\n");

    // Serve requests based on the direction
    if (direction == 1)
    { // Moving towards the right
        for (i = pos; i < n; i++)
        {
            int seek_time = abs(requests[i] - head);
            total_seek_time += seek_time;
            printf("%d\t\t%d\t\t\t%d\n", requests[i], head, seek_time);
            head = requests[i];
        }
        // Go to the end of the disk if necessary
        if (head != disk_size - 1)
        {
            int seek_time = abs((disk_size - 1) - head);
            total_seek_time += seek_time;
            printf("%d\t\t%d\t\t\t%d\n", disk_size - 1, head, seek_time);
            head = disk_size - 1;
        }
        // Reverse direction and continue serving requests to the left
        for (i = pos - 1; i >= 0; i--)
        {
            int seek_time = abs(requests[i] - head);
            total_seek_time += seek_time;
            printf("%d\t\t%d\t\t\t%d\n", requests[i], head, seek_time);
            head = requests[i];
        }
    }
    else
    { // Moving towards the left
        for (i = pos - 1; i >= 0; i--)
        {
            int seek_time = abs(requests[i] - head);
            total_seek_time += seek_time;
            printf("%d\t\t%d\t\t\t%d\n", requests[i], head, seek_time);
            head = requests[i];
        }
        // Go to the start of the disk if necessary
        if (head != 0)
        {
            int seek_time = abs(head - 0);
            total_seek_time += seek_time;
            printf("%d\t\t%d\t\t\t%d\n", 0, head, seek_time);
            head = 0;
        }
        // Reverse direction and continue serving requests to the right
        for (i = pos; i < n; i++)
        {
            int seek_time = abs(requests[i] - head);
            total_seek_time += seek_time;
            printf("%d\t\t%d\t\t\t%d\n", requests[i], head, seek_time);
            head = requests[i];
        }
    }

    printf("\nTotal Seek Time: %d\n", total_seek_time);
}

int main()
{
    int n, head, disk_size, direction;

    // Input number of requests
    printf("Enter the number of disk requests: ");
    scanf("%d", &n);

    int requests[n];

    // Input the disk requests
    printf("Enter the disk requests:\n");
    for (int i = 0; i < n; i++)
    {
        printf("Request %d: ", i + 1);
        scanf("%d", &requests[i]);
    }

    // Input initial head position
    printf("Enter the initial head position: ");
    scanf("%d", &head);

    // Input the size of the disk
    printf("Enter the disk size: ");
    scanf("%d", &disk_size);

    // Input direction (1 for right, 0 for left)
    printf("Enter the initial direction (1 for right, 0 for left): ");
    scanf("%d", &direction);

    // Call the SCAN function to calculate seek time
    SCAN(head, requests, n, disk_size, direction);

    return 0;
}


// Shortest Job First (Preemptive and Non Preemptive)

#include <stdio.h>
#include <stdbool.h>

struct Process
{
    int pid; // Process ID
    int arrivalTime;
    int burstTime;
    int remainingTime; // For preemptive SJF
    int finishTime;
    int turnAroundTime;
    int waitingTime;
    bool isCompleted;
};

// Function for Non-Preemptive SJF
void sjfNonPreemptive(struct Process processes[], int n)
{
    int currentTime = 0, completed = 0;

    while (completed < n)
    {
        int minIndex = -1;
        int minBurstTime = 1e9;

        // Select the process with the smallest burst time that has arrived
        for (int i = 0; i < n; i++)
        {
            if (!processes[i].isCompleted && processes[i].arrivalTime <= currentTime &&
                processes[i].burstTime < minBurstTime)
            {
                minBurstTime = processes[i].burstTime;
                minIndex = i;
            }
        }

        if (minIndex == -1)
        {
            currentTime++;
        }
        else
        {
            // Calculate the finish time, turnaround time, and waiting time
            processes[minIndex].finishTime = currentTime + processes[minIndex].burstTime;
            processes[minIndex].turnAroundTime = processes[minIndex].finishTime - processes[minIndex].arrivalTime;
            processes[minIndex].waitingTime = processes[minIndex].turnAroundTime - processes[minIndex].burstTime;
            processes[minIndex].isCompleted = true;

            currentTime = processes[minIndex].finishTime;
            completed++;
        }
    }
}

// Function for Preemptive SJF
void sjfPreemptive(struct Process processes[], int n)
{
    int currentTime = 0, completed = 0;
    int minIndex = -1;
    int minRemainingTime = 1e9;

    while (completed < n)
    {
        minIndex = -1;
        minRemainingTime = 1e9;

        // Select the process with the smallest remaining time that has arrived
        for (int i = 0; i < n; i++)
        {
            if (processes[i].arrivalTime <= currentTime && !processes[i].isCompleted &&
                processes[i].remainingTime < minRemainingTime)
            {
                minRemainingTime = processes[i].remainingTime;
                minIndex = i;
            }
        }

        if (minIndex != -1)
        {
            processes[minIndex].remainingTime--;
            currentTime++;

            // If process is completed
            if (processes[minIndex].remainingTime == 0)
            {
                processes[minIndex].finishTime = currentTime;
                processes[minIndex].turnAroundTime = processes[minIndex].finishTime - processes[minIndex].arrivalTime;
                processes[minIndex].waitingTime = processes[minIndex].turnAroundTime - processes[minIndex].burstTime;
                processes[minIndex].isCompleted = true;
                completed++;
            }
        }
        else
        {
            currentTime++;
        }
    }
}

void displayResults(struct Process processes[], int n)
{
    printf("PID\tArrival\tBurst\tFinish\tTurnaround\tWaiting\n");
    for (int i = 0; i < n; i++)
    {
        printf("%d\t%d\t%d\t%d\t%d\t\t%d\n",
               processes[i].pid,
               processes[i].arrivalTime,
               processes[i].burstTime,
               processes[i].finishTime,
               processes[i].turnAroundTime,
               processes[i].waitingTime);
    }

    float totalTurnAroundTime = 0, totalWaitingTime = 0;
    for (int i = 0; i < n; i++)
    {
        totalTurnAroundTime += processes[i].turnAroundTime;
        totalWaitingTime += processes[i].waitingTime;
    }

    printf("Average Turnaround Time: %.2f\n", totalTurnAroundTime / n);
    printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
}

int main()
{
    int n, choice;
    printf("Enter the number of processes: ");
    scanf("%d", &n);

    struct Process processes[n];
    for (int i = 0; i < n; i++)
    {
        processes[i].pid = i + 1;
        printf("Enter arrival time and burst time for process %d: ", processes[i].pid);
        scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
        processes[i].remainingTime = processes[i].burstTime;
        processes[i].isCompleted = false;
    }

    printf("Choose Scheduling:\n1. Non-Preemptive SJF\n2. Preemptive SJF\n");
    scanf("%d", &choice);

    if (choice == 1)
    {
        sjfNonPreemptive(processes, n);
    }
    else if (choice == 2)
    {
        sjfPreemptive(processes, n);
    }
    else
    {
        printf("Invalid choice!\n");
        return 0;
    }

    displayResults(processes, n);
    return 0;
}


// SSTF disk scheduling

#include <stdio.h>
#include <stdlib.h>

void SSTF(int head, int requests[], int n)
{
    int total_seek_time = 0;
    int completed[n]; // Array to track completed requests
    for (int i = 0; i < n; i++)
        completed[i] = 0; // Mark all requests as incomplete initially

    printf("\nSSTF Disk Scheduling\n");
    printf("Initial Head Position: %d\n", head);

    printf("\nRequest\tCurrent Head Position\tSeek Time\n");
    printf("-------\t----------------------\t---------\n");

    for (int i = 0; i < n; i++)
    {
        int closest = -1;
        int min_seek_time = 9999;

        // Find the closest request
        for (int j = 0; j < n; j++)
        {
            if (!completed[j])
            { // Only consider uncompleted requests
                int seek_time = abs(requests[j] - head);
                if (seek_time < min_seek_time)
                {
                    min_seek_time = seek_time;
                    closest = j;
                }
            }
        }

        // Move the head to the closest request
        int seek_time = abs(requests[closest] - head);
        total_seek_time += seek_time;

        printf("%d\t\t%d\t\t\t%d\n", requests[closest], head, seek_time);

        head = requests[closest];
        completed[closest] = 1; // Mark this request as completed
    }

    printf("\nTotal Seek Time: %d\n", total_seek_time);
}

int main()
{
    int n, head;

    // Input number of requests
    printf("Enter the number of disk requests: ");
    scanf("%d", &n);

    int requests[n];

    // Input the disk requests
    printf("Enter the disk requests:\n");
    for (int i = 0; i < n; i++)
    {
        printf("Request %d: ", i + 1);
        scanf("%d", &requests[i]);
    }

    // Input initial head position
    printf("Enter the initial head position: ");
    scanf("%d", &head);

    // Call the SSTF function to calculate seek time
    SSTF(head, requests, n);

    return 0;
}


//system calls

#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <string.h>
 
void process_related() {
    int choice;
    pid_t pid;
   
    printf("\nProcess Related System Calls:\n");
    printf("1. fork()\n");
    printf("2. exit()\n");
    printf("3. wait()\n");
    printf("4. exec()\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);
 
    switch(choice) {
        case 1:
            pid = fork();
            if (pid == 0) {
                printf("This is the child process. PID = %d\n", getpid());
                exit(0);
            } else {
                printf("This is the parent process. PID = %d\n", getpid());
            }
            break;
 
        case 2:
            printf("Exiting with status 0...\n");
            exit(0);
            break;
 
        case 3:
            pid = fork();
            if (pid == 0) {
                printf("Child process. PID = %d\n", getpid());
                exit(0);
            } else {
                wait(NULL);
                printf("Child process finished. Parent PID = %d\n", getpid());
            }
            break;
 
        case 4:
            pid = fork();
            if (pid == 0) {
                printf("Child process executing ls command:\n");
                execl("/bin/ls", "ls", NULL);
                exit(0);
            } else {
                wait(NULL);
                printf("ls command executed by child process.\n");
            }
            break;
 
        default:
            printf("Invalid choice.\n");
            break;
    }
}
 
void communication_related() {
    int choice;
    int fd[2];
    char write_msg[20] = "Hello, World!";
    char read_msg[20];
    pid_t pid;
 
    printf("\nCommunication Related System Calls:\n");
    printf("1. pipe()\n");
    printf("2. FIFO (named pipe)\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);
 
    switch(choice) {
        case 1:
            if (pipe(fd) == -1) {
                perror("Pipe failed");
                exit(1);
            }
 
            pid = fork();
            if (pid == 0) {
                close(fd[0]); // Close unused read end
                write(fd[1], write_msg, strlen(write_msg)+1);
                close(fd[1]);
            } else {
                close(fd[1]); // Close unused write end
                read(fd[0], read_msg, sizeof(read_msg));
                printf("Received message: %s\n", read_msg);
                close(fd[0]);
            }
            break;
 
        case 2:
            mkfifo("/tmp/myfifo", 0666);
            pid = fork();
 
            if (pid == 0) {
                int fd = open("/tmp/myfifo", O_WRONLY);
                write(fd, write_msg, strlen(write_msg)+1);
                close(fd);
                exit(0);
            } else {
                int fd = open("/tmp/myfifo", O_RDONLY);
                read(fd, read_msg, sizeof(read_msg));
                printf("Received message: %s\n", read_msg);
                close(fd);
            }
            unlink("/tmp/myfifo");
            break;
 
        default:
            printf("Invalid choice.\n");
            break;
    }
}
 
void file_related() {
    int choice;
    int fd;
    char buffer[100];
 
    printf("\nFile Related System Calls:\n");
    printf("1. open(), write(), close()\n");
    printf("2. link(), stat(), unlink()\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);
 
    switch(choice) {
        case 1:
            fd = open("example.txt", O_WRONLY | O_CREAT, 0644);
            if (fd == -1) {
                perror("Error opening file");
                exit(1);
            }
 
            write(fd, "Hello, World!\n", 14);
            close(fd);
            printf("File written and closed successfully.\n");
 
            fd = open("example.txt", O_RDONLY);
            read(fd, buffer, 100);
            printf("File content: %s", buffer);
            close(fd);
            break;
 
        case 2:
            link("example.txt", "example_link.txt");
            struct stat file_stat;
            stat("example_link.txt", &file_stat);
            printf("File size: %ld bytes\n", file_stat.st_size);
            unlink("example_link.txt");
            printf("Link removed.\n");
            break;
 
        default:
            printf("Invalid choice.\n");
            break;
    }
}
 
void info_related() {
    int choice;
 
    printf("\nInformation Related System Calls:\n");
    printf("1. alarm()\n");
    printf("2. sleep()\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);
 
    switch(choice) {
        case 1:
            printf("Setting an alarm for 5 seconds...\n");
            alarm(5);
            sleep(6); // To show the alarm trigger
            break;
 
        case 2:
            printf("Sleeping for 3 seconds...\n");
            sleep(3);
            printf("Woke up after 3 seconds.\n");
            break;
 
        default:
            printf("Invalid choice.\n");
            break;
    }
}
 
int main() {
    int choice;
 
    while(1) {
        printf("\nMenu:\n");
        printf("1. Process Related\n");
        printf("2. Communication Related\n");
        printf("3. File Related\n");
        printf("4. Information Related\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
 
        switch(choice) {
            case 1:
                process_related();
                break;
 
            case 2:
                communication_related();
                break;
 
            case 3:
                file_related();
                break;
 
            case 4:
                info_related();
                break;
 
            case 5:
                printf("Exiting...\n");
                exit(0);
 
            default:
                printf("Invalid choice.\n");
                break;
        }
    }
 
    return 0;
}


//finish time, turnaround time and waiting time for the First come First serve


#include <stdio.h>


struct Process {
    int pid;       // Process ID
    int arrivalTime;
    int burstTime;
    int finishTime;
    int turnAroundTime;
    int waitingTime;
};


void calculateTimes(struct Process processes[], int n) {
    int currentTime = 0;


    for (int i = 0; i < n; i++) {
        // If the process arrives after the current time, update the current time to the arrival time of the process
        if (currentTime < processes[i].arrivalTime) {
            currentTime = processes[i].arrivalTime;
        }


        // Finish time is the current time plus the burst time
        processes[i].finishTime = currentTime + processes[i].burstTime;


        // Turnaround time is finish time minus arrival time
        processes[i].turnAroundTime = processes[i].finishTime - processes[i].arrivalTime;


        // Waiting time is turnaround time minus burst time
        processes[i].waitingTime = processes[i].turnAroundTime - processes[i].burstTime;


        // Update current time to finish time of the current process
        currentTime = processes[i].finishTime;
    }
}


void displayResults(struct Process processes[], int n) {
    printf("PID\tArrival\tBurst\tFinish\tTurnaround\tWaiting\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\t%d\t\t%d\n",
               processes[i].pid,
               processes[i].arrivalTime,
               processes[i].burstTime,
               processes[i].finishTime,
               processes[i].turnAroundTime,
               processes[i].waitingTime);
    }


    float totalTurnAroundTime = 0, totalWaitingTime = 0;
    for (int i = 0; i < n; i++) {
        totalTurnAroundTime += processes[i].turnAroundTime;
        totalWaitingTime += processes[i].waitingTime;
    }


    printf("Average Turnaround Time: %.2f\n", totalTurnAroundTime / n);
    printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
}


int main() {
    int n;


    printf("Enter the number of processes: ");
    scanf("%d", &n);


    struct Process processes[n];


    for (int i = 0; i < n; i++) {
        processes[i].pid = i + 1;
        printf("Enter arrival time and burst time for process %d: ", processes[i].pid);
        scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
    }


    // Sort processes by arrival time (FCFS scheduling)
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (processes[i].arrivalTime > processes[j].arrivalTime) {
                struct Process temp = processes[i];
                processes[i] = processes[j];
                processes[j] = temp;
            }
        }
    }


    calculateTimes(processes, n);
    displayResults(processes, n);


    return 0;
}


//finish time, turnaround time and waiting time for the Priority (Preemptive and Non Preemptive)


#include <stdio.h>
#include <stdbool.h>


struct Process {
    int pid;          // Process ID
    int arrivalTime;
    int burstTime;
    int remainingTime; // For preemptive scheduling
    int priority;
    int finishTime;
    int turnAroundTime;
    int waitingTime;
    bool isCompleted;
};


// Function for Non-Preemptive Priority Scheduling
void priorityNonPreemptive(struct Process processes[], int n) {
    int currentTime = 0, completed = 0;


    while (completed < n) {
        int minIndex = -1;
        int highestPriority = 1e9;


        // Select the process with the highest priority that has arrived
        for (int i = 0; i < n; i++) {
            if (!processes[i].isCompleted && processes[i].arrivalTime <= currentTime &&
                processes[i].priority < highestPriority) {
                highestPriority = processes[i].priority;
                minIndex = i;
            }
        }


        if (minIndex == -1) {
            currentTime++;
        } else {
            // Calculate the finish time, turnaround time, and waiting time
            processes[minIndex].finishTime = currentTime + processes[minIndex].burstTime;
            processes[minIndex].turnAroundTime = processes[minIndex].finishTime - processes[minIndex].arrivalTime;
            processes[minIndex].waitingTime = processes[minIndex].turnAroundTime - processes[minIndex].burstTime;
            processes[minIndex].isCompleted = true;


            currentTime = processes[minIndex].finishTime;
            completed++;
        }
    }
}


// Function for Preemptive Priority Scheduling
void priorityPreemptive(struct Process processes[], int n) {
    int currentTime = 0, completed = 0;


    while (completed < n) {
        int minIndex = -1;
        int highestPriority = 1e9;


        // Select the process with the highest priority that has arrived
        for (int i = 0; i < n; i++) {
            if (processes[i].arrivalTime <= currentTime && !processes[i].isCompleted &&
                processes[i].priority < highestPriority) {
                highestPriority = processes[i].priority;
                minIndex = i;
            }
        }


        if (minIndex != -1) {
            // Process one unit of the burst time
            processes[minIndex].remainingTime--;
            currentTime++;


            // If process is completed
            if (processes[minIndex].remainingTime == 0) {
                processes[minIndex].finishTime = currentTime;
                processes[minIndex].turnAroundTime = processes[minIndex].finishTime - processes[minIndex].arrivalTime;
                processes[minIndex].waitingTime = processes[minIndex].turnAroundTime - processes[minIndex].burstTime;
                processes[minIndex].isCompleted = true;
                completed++;
            }
        } else {
            currentTime++;
        }
    }
}


void displayResults(struct Process processes[], int n) {
    printf("PID\tArrival\tBurst\tPriority\tFinish\tTurnaround\tWaiting\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\t\t%d\t%d\t\t%d\n",
               processes[i].pid,
               processes[i].arrivalTime,
               processes[i].burstTime,
               processes[i].priority,
               processes[i].finishTime,
               processes[i].turnAroundTime,
               processes[i].waitingTime);
    }


    float totalTurnAroundTime = 0, totalWaitingTime = 0;
    for (int i = 0; i < n; i++) {
        totalTurnAroundTime += processes[i].turnAroundTime;
        totalWaitingTime += processes[i].waitingTime;
    }


    printf("Average Turnaround Time: %.2f\n", totalTurnAroundTime / n);
    printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
}


int main() {
    int n, choice;
    printf("Enter the number of processes: ");
    scanf("%d", &n);


    struct Process processes[n];
    for (int i = 0; i < n; i++) {
        processes[i].pid = i + 1;
        printf("Enter arrival time, burst time, and priority for process %d: ", processes[i].pid);
        scanf("%d %d %d", &processes[i].arrivalTime, &processes[i].burstTime, &processes[i].priority);
        processes[i].remainingTime = processes[i].burstTime;
        processes[i].isCompleted = false;
    }


    printf("Choose Scheduling:\n1. Non-Preemptive Priority\n2. Preemptive Priority\n");
    scanf("%d", &choice);


    if (choice == 1) {
        priorityNonPreemptive(processes, n);
    } else if (choice == 2) {
        priorityPreemptive(processes, n);
    } else {
        printf("Invalid choice!\n");
        return 0;
    }


    displayResults(processes, n);
    return 0;
}


// finish time, turnaround time and waiting time for the Round robin

#include <stdio.h>


struct Process {
    int pid;           // Process ID
    int arrivalTime;   // Arrival time
    int burstTime;     // Burst time
    int remainingTime; // Remaining burst time
    int finishTime;    // Finish time
    int turnAroundTime; // Turnaround time
    int waitingTime;   // Waiting time
};


void roundRobin(struct Process processes[], int n, int quantum) {
    int currentTime = 0;
    int completed = 0;
    int timeQuantum = quantum;


    while (completed < n) {
        int done = 1;


        for (int i = 0; i < n; i++) {
            // Check if process has remaining time and has arrived
            if (processes[i].remainingTime > 0 && processes[i].arrivalTime <= currentTime) {
                done = 0;


                // If remaining time is less than or equal to time quantum, process will finish
                if (processes[i].remainingTime <= timeQuantum) {
                    currentTime += processes[i].remainingTime;
                    processes[i].finishTime = currentTime;
                    processes[i].turnAroundTime = processes[i].finishTime - processes[i].arrivalTime;
                    processes[i].waitingTime = processes[i].turnAroundTime - processes[i].burstTime;
                    processes[i].remainingTime = 0;
                    completed++;
                } else {
                    // Process runs for the time quantum
                    processes[i].remainingTime -= timeQuantum;
                    currentTime += timeQuantum;
                }
            }
        }


        // If all processes are done
        if (done) {
            currentTime++;
        }
    }
}


void displayResults(struct Process processes[], int n) {
    printf("PID\tArrival\tBurst\tFinish\tTurnaround\tWaiting\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\t%d\t\t%d\n",
               processes[i].pid,
               processes[i].arrivalTime,
               processes[i].burstTime,
               processes[i].finishTime,
               processes[i].turnAroundTime,
               processes[i].waitingTime);
    }


    float totalTurnAroundTime = 0, totalWaitingTime = 0;
    for (int i = 0; i < n; i++) {
        totalTurnAroundTime += processes[i].turnAroundTime;
        totalWaitingTime += processes[i].waitingTime;
    }


    printf("Average Turnaround Time: %.2f\n", totalTurnAroundTime / n);
    printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
}


int main() {
    int n, quantum;


    printf("Enter the number of processes: ");
    scanf("%d", &n);
    struct Process processes[n];


    for (int i = 0; i < n; i++) {
        processes[i].pid = i + 1;
        printf("Enter arrival time and burst time for process %d: ", processes[i].pid);
        scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
        processes[i].remainingTime = processes[i].burstTime;
    }


    printf("Enter the time quantum: ");
    scanf("%d", &quantum);


    roundRobin(processes, n, quantum);
    displayResults(processes, n);


    return 0;
}


// 1)zombie process 2)orphan processes 3)sum of even numbers

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void zombie_process()
{
    pid_t pid = fork();

    if (pid > 0)
    {
        // Parent process
        printf("Parent process started, PID: %d\n", getpid());
        printf("Child process PID: %d\n", pid);

        // Give time for child process to exit and become a zombie
        printf("\nRunning 'ps -l' to show zombie process:\n");
        fflush(stdout);
        system("ps -l | grep Z"); // Show zombie process

        // Wait a while before cleaning up the zombie
        printf("\nParent process is cleaning up the zombie process...\n");
        fflush(stdout);
        wait(NULL); // Clean up the zombie process
        printf("Zombie process cleaned up.\n");
    }
    else if (pid == 0)
    {
        // Child process
        printf("Child process started, PID: %d\n", getpid());
        printf("Child process exiting to become a zombie.\n");
        exit(0); // Child exits, becomes a zombie until parent calls wait()
    }
    else
    {
        // Fork failed
        printf("Fork failed!\n");
    }
}

void orphan_process()
{
    pid_t pid = fork();

    if (pid > 0)
    {
        // Parent process
        printf("Parent process is running, PID: %d\n", getpid());
        printf("Parent process will sleep for 1 second to allow the child to become an orphan.\n");
        sleep(1);
        printf("Parent process is exiting, child will become an orphan.\n");
        exit(0); // Parent exits, making the child an orphan
    }
    else if (pid == 0)
    {
        // Child process
        printf("Child process started, PID: %d. Parent PID: %d\n", getpid(), getppid());
        sleep(3); // Sleep to ensure it outlives the parent
        printf("Child process awoke, PID: %d. Checking new Parent PID...\n", getpid());
        printf("Child process is now an orphan and adopted by init. New Parent PID: %d\n", getppid());
    }
    else
    {
        // Fork failed
        printf("Fork failed!\n");
    }
}

void calculate_sums()
{
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // Sample array
    int n = sizeof(arr) / sizeof(arr[0]);
    int even_sum = 0, odd_sum = 0;
    pid_t pid = fork();

    if (pid > 0)
    {
        // Parent process: Calculate sum of even numbers
        wait(NULL); // Wait for child process to complete
        for (int i = 0; i < n; i++)
        {
            if (arr[i] % 2 == 0)
            {
                even_sum += arr[i];
            }
        }
        printf("Parent Process (Even Sum): %d\n", even_sum);
    }
    else if (pid == 0)
    {
        // Child process: Calculate sum of odd numbers
        for (int i = 0; i < n; i++)
        {
            if (arr[i] % 2 != 0)
            {
                odd_sum += arr[i];
            }
        }
        printf("Child Process (Odd Sum): %d\n", odd_sum);
        exit(0); // End child process
    }
    else
    {
        // Fork failed
        printf("Fork failed!\n");
    }
}

int main()
{
    printf("Running zombie process demonstration:\n");
    zombie_process();

    printf("\nRunning orphan process demonstration:\n");
    orphan_process();

    printf("\nCalculating sums in parent and child processes:\n");
    calculate_sums();

    return 0;
}
